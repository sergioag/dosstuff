TITLE DISK2 ---- 10/28/85  FIXED DISK BIOS

;--  INT  13H  --------------------------------------------------
;                                                               :
; FIXED DISK I/O INTERFACE                                      :
;                                                               :
;       THIS INTERFACE PROVIDES ACCESS TO FIXED DISKS           ;
;       THROUGH THE IBM FIXED DISK CONTROLLER.                  ;
;                                                               ;
;----------------------------------------------------------------

;----------------------------------------------------------------
;       THE  BIOS ROUTINES ARE MEANT TO BE ACCESSED THROUGH     :
;       SOFTWARE INTERRUPTS ONLY.  ANY ADDRESSES PRESENT IN     :
;       THE LISTINGS  ARE INCLUDED  ONLY FOR  COMPLETENESS,     :
;       NOT FOR  REFERENCE.   APPLICATIONS WHICH  REFERENCE     :
;       ABSOLUTE   ADDRESSES   WITHIN   THE   CODE  SEGMENT     :
;       VIOLATE THE STRUCTURE AND DESIGN OF BIOS.               :
;----------------------------------------------------------------
;
; INPUT (AH = HEX VALUE)
;
;       (AH)= 00H  RESET DISK (DL = 80H,81H) / DISKETTE
;       (AH)= 01H  READ THE STATUS OF THE LAST DISK OPERATION INTO (AL)
;                  NOTE: DL < 80H - DISKETTE
;                        DL > 80H - DISK
;       (AH)= 02H  READ THE DESIRED SECTORS INTO MEMORY
;       (AH)= 03H  WRITE THE DESIRED SECTORS FROM MEMORY
;       (AH)= 04H  VERIFY THE DESIRED SECTORS
;       (AH)= 05H  FORMAT THE DESIRED TRACK
;       (AH)= 06H  FORMAT THE DESIRED TRACK AND SET BAD SECTOR FLAGS
;       (AH)= 07H  FORMAT THE DRIVE STARTING AT THE DESIRED TRACK
;       (AH)= 08H  RETURN THE CURRENT DRIVE PARAMETERS
;
;       (AH)= 09H  INITIALIZE DRIVE PAIR CHARACTERISTICS
;                  INTERRUPT 41 POINTS TO DATA BLOCK
;       (AH)= 0AH  READ LONG
;       (AH)= 0BH  WRITE LONG
;                  NOTE: READ AND WRITE LONG ENCOMPASS
;                  512 + 4 BYTES ECC
;       (AH)= 0CH  SEEK
;       (AH)= 0DH  ALTERNATE DISK RESET (SEE DL)
;       (AH)= 0EH  READ DISK SECTOR BUFFER
;       (AH)= 0FH  WRITE SECTOR BUFFER,
;                  (RECOMMENDED PRACTICE BEFORE FORMATTING)
;       (AH)= 10H  TEST DRIVE READY
;       (AH)= 11H  RECALIBRATE
;       (AH)= 12H  CONTROLLER RAM DIAGNOSTIC
;       (AH)= 13H  DRIVE DIAGNOSTIC
;       (AH)= 14H  CONTROLLER INTERNAL DIAGNOSTIC
;
;               REGISTERS USED FOR FIXED DISK OPERATIONS
;
;               (DL)    -  DRIVE NUMBER     (80H-87H FOR DISK, VALUE CHECKED)
;               (DH)    -  HEAD NUMBER      (0-7 ALLOWED, NOT VALUE CHECKED)
;               (CH)    -  CYLINDER NUMBER  (0-1023, NOT VALUE CHECKED)(SEE CL)
;               (CL)    -  SECTOR NUMBER    (1-17, NOT VALUE CHECKED)
;
;                          NOTE: HIGH 2 BITS OF CYLINDER NUMBER ARE PLACED
;                                IN THE HIGH 2 BITS OF THE CL REGISTER
;                                (10 BITS TOTAL)
;               (AL)    -  NUMBER OF SECTORS (MAXIMUM RANGE 1-80H,
;                                             FOR READ/WRITE LONG 1-79H)
;                          (INTERLEAVE VALUE FOR FORMAT 1-16D)
;               (ES:BX) -  ADDRESS OF BUFFER FOR READS AND WRITES,
;                          (NOT REQUIRED FOR VERIFY)
;
; OUTPUT
;       AH = STATUS OF CURRENT OPERATION
;            STATUS BITS ARE DEFINED IN THE EQUATES BELOW
;       CY = 0  SUCCESSFUL OPERATION (AH=0 ON RETURN)
;       CY = 1  FAILED OPERATION (AH HAS ERROR REASON)
;
;       NOTE:   ERROR 11H  INDICATES THAT THE DATA READ HAD A RECOVERABLE
;               ERROR WHICH WAS CORRECTED BY THE ECC ALGORITHM.  THE DATA
;               IS PROBABLY GOOD,   HOWEVER THE BIOS ROUTINE INDICATES AN
;               ERROR TO ALLOW THE CONTROLLING PROGRAM A CHANCE TO DECIDE
;               FOR  ITSELF.  THE  ERROR  MAY  NOT  RECUR  IF THE DATA IS
;               REWRITTEN. (AL) CONTAINS THE BURST LENGTH.
;
;       IF DRIVE PARAMETERS WERE REQUESTED,
;
;               DL = NUMBER OF CONSECUTIVE ACKNOWLEDGING DRIVES
;                    ATTACHED (0-2)  (CONTROLLER CARD ZERO TALLY ONLY)
;               DH = MAXIMUM USEABLE VALUE FOR HEAD NUMBER
;               CH = MAXIMUM USEABLE VALUE FOR CYLINDER NUMBER
;               CL = MAXIMUM USEABLE VALUE FOR SECTOR NUMBER
;                    AND CYLINDER NUMBER HIGH BITS
;
;       IF AN ERROR OCCURS ON READ DRIVE PARAMETERS,
;
;               AH = ERROR CODE (INIT_FAIL)
;               AL = CX = DX = 0
;
;       REGISTERS WILL BE PRESERVED EXCEPT WHEN THEY ARE USED TO RETURN
;       INFORMATION.
;
;       NOTE: IF AN ERROR IS REPORTED BY THE DISK CODE, THE APPROPRIATE
;               ACTION IS TO RESET THE DISK, THEN RETRY THE OPERATION.
;
;------------------------------------------------------------------------

;--------------------------------------------------------
;       ERROR RETURN STATUS  (AH)= ??H  WHEN  CY= 1     :
;--------------------------------------------------------

SENSE_FAIL	EQU	0FFH		; SENSE OPERATION FAILED
WRITE_FAULT	EQU	0CCH		; WRITE FAULT ON SELECTED DRIVE
UNDEF_ERR	EQU	0BBH		; UNDEFINED ERROR OCCURRED
TIME_OUT	EQU	080H		; ATTACHMENT FAILED TO RESPOND
BAD_SEEK	EQU	040H		; SEEK OPERATION FAILED
BAD_CNTLR	EQU	020H		; CONTROLLER HAS FAILED
DATA_CORRECTED	EQU	011H		; ECC CORRECTED DATA ERROR
BAD_ECC		EQU	010H		; BAD ECC ON DISK READ
BAD_TRACK	EQU	00BH		; BAD TRACK FLAG DETECTED
DMA_BOUNDARY	EQU	009H		; ATTEMPT TO DMA ACROSS 64K BOUNDARY
INIT_FAIL	EQU	007H		; DRIVE PARAMETER ACTIVITY FAILED
BAD_RESET	EQU	005H		; RESET FAILED
RECORD_NOT_FND	EQU	004H		; REQUESTED SECTOR NOT FOUND
BAD_ADDR_MARK	EQU	002H		; ADDRESS MARK NOT FOUND
BAD_CMD		EQU	001H		; BAD COMMAND PASSED TO DISK I/O

;----------------------------------------
;       INTERRUPT AND STATUS AREAS      :
;----------------------------------------

ABS0	SEGMENT AT 0
		ORG	00DH*4		; FIXED DISK INTERRUPT VECTOR
HDISK_INT	LABEL	DWORD
		ORG	13H*4		; DISK INTERRUPT VECTOR
ORG_VECTOR	LABEL	DWORD
		ORG	19H*4		; BOOTSTRAP INTERRUPT VECTOR
BOOT_VEC	LABEL	DWORD
		ORG	1EH*4		; DISKETTE PARAMETERS
DISKETTE_PARM	LABEL	DWORD
		ORG	040H*4		; NEW DISKETTE INTERRUPT VECTOR
DISK_VECTOR	LABEL	DWORD
		ORG	041H*4		; FIXED DISK PARAMETER VECTOR
HF_TBL_VEC	LABEL	DWORD
		ORG	7C00H		; BOOTSTRAP LOADER VECTOR
BOOT_LOCN	LABEL	FAR
ABS0	ENDS

DATA	SEGMENT AT 40H
	ORG	06CH
TIMER_LOW	DW	?		; TIMER LOW WORD
	ORG	72H
RESET_FLAG	DW	?		; 1234H IF KEYBOARD RESET UNDERWAY
	ORG	74H
DISK_STATUS	DB	?		; FIXED DISK STATUS BYTE
HF_NUM		DB	?		; COUNT OF FIXED DISK DRIVES
CONTROL_BYTE	DB	?		; CONTROL BYTE DRIVE OPTIONS
PORT_OFF	DB	?		; PORT OFFSET
DATA	ENDS

CODE	SEGMENT

;--------------------------------------------------------
; HARDWARE SPECIFIC VALUES                              :
;                                                       :
;  -  CONTROLLER I/O PORT                               :
;     > WHEN READ FROM:                                 :
;       HF_PORT+0 - READ DATA (FROM CONTROLLER TO CPU)  :
;       HF_PORT+1 - READ CONTROLLER HARDWARE STATUS     :
;                   (CONTROLLER TO CPU)                 :
;       HF_PORT+2 - READ CONFIGURATION SWITCHES         :
;       HF_PORT+3 - NOT USED                            :
;     > WHEN WRITTEN TO:                                :
;       HF_PORT+0 - WRITE DATA (FROM CPU TO CONTROLLER) :
;       HF_PORT+1 - CONTROLLER RESET                    :
;       HF_PORT+2 - GENERATE CONTROLLER SELECT PULSE    :
;       HF_PORT+3 - WRITE PATTERN TO DMA AND INTERRUPT  :
;                   MASK REGISTER                       ;
;                                                       ;
;--------------------------------------------------------

CMD_BLOCK	EQU	BYTE PTR [BP]-8	; CMD BLOCK HEAD
HF_PORT		EQU	0320H		; DISK PORT
INTA00		EQU	020H		; 8259 PORT
INTA01		EQU	021H		; 8259 PORT
EOI		EQU	020H		; END OF INTERRUPT COMMAND
R1_BUSY		EQU	00001000B	; DISK PORT 1 BUSY BIT
R1_BUS		EQU	00000100B	;             COMMAND/DATA BIT
R1_IOMODE	EQU	00000010B	;             MODE BIT
R1_REQ		EQU	00000001B	;             REQUEST BIT

DMA_READ	EQU	01000111B	; CHANNEL 3 (047H)
DMA_WRITE	EQU	01001011B	; CHANNEL 3 (04BH)
DMA		EQU	000H		; DMA ADDRESS
DMA_HIGH	EQU	082H		; PORT FOR HIGH 4 BITS OF DMA

TST_RDY_CMD	EQU	00000000B	; CNTLR READY (00H)
RECAL_CMD	EQU	00000001B	;       RECAL (01H)
SENSE_CMD	EQU	00000011B	;       SENSE (03H)
FMTDRV_CMD	EQU	00000100B	;       DRIVE (04H)
CHK_TRK_CMD	EQU	00000101B	;       T CHK (05H)
FMTTRK_CMD	EQU	00000110B	;       TRACK (06H)
FMTBAD_CMD	EQU	00000111B	;       BAD   (07H)
READ_CMD	EQU	00001000B	;       READ  (08H)
WRITE_CMD	EQU	00001010B	;       WRITE (0AH)
SEEK_CMD	EQU	00001011B	;       SEEK  (0BH)
INIT_DRV_CMD	EQU	00001100B	;       INIT  (0CH)
RD_ECC_CMD	EQU	00001101B	;       BURST (0DH)
RD_BUFF_CMD	EQU	00001110B	;       BUFFR (0EH)
WR_BUFF_CMD	EQU	00001111B	;       BUFFR (0FH)
RAM_DIAG_CMD	EQU	11100000B	;       RAM   (E0H)
CHK_DRV_CMD	EQU	11100011B	;       DRV   (E3H)
CNTLR_DIAG_CMD	EQU	11100100B	;       CNTLR (E4H)
RD_LONG_CMD	EQU	11100101B	;       RLONG (E5H)
WR_LONG_CMD	EQU	11100110B	;       WLONG (E6H)

MAX_FILE	EQU	8
S_MAX_FILE	EQU	2

	ASSUME	CS:CODE,DS:ABS0
	ORG	0H
	DB	055H			; GENERIC BIOS HEADER
	DB	0AAH
	DB	16D			; 4K MODULE

;----------------------------------------------------------------
; FIXED DISK I/O SETUP                                          :
;                                                               :
;  -  ESTABLISH TRANSFER VECTORS FOR THE FIXED DISK             :
;  -  PERFORM POWER ON DIAGNOSTICS                              :
;     SHOULD AN ERROR OCCUR A "1701" MESSAGE IS DISPLAYED       :
;                                                               :
;----------------------------------------------------------------

DISK_SETUP	PROC	FAR
	JMP	SHORT	L3
	DB	'59X7291 (C) COPYRIGHT IBM  CORP.'	; COPYRIGHT NOTICE
	DB	',1982 ,1985.'
	DB	' 10/28/85'				; RELEASE MARKER
L3:
	SUB	AX,AX					; ADDRESS LOW RAM
	MOV	DS,AX
	CLI
	MOV	AX,WORD PTR ORG_VECTOR			; LOAD DISKETTE IP
	MOV	WORD PTR DISK_VECTOR,AX			; STORE AT INT 40H
	MOV	AX,WORD PTR ORG_VECTOR+2		; LOAD DISKETTE CS
	MOV	WORD PTR DISK_VECTOR+2,AX		; SORE AT INT 40H
	MOV	WORD PTR ORG_VECTOR, OFFSET DISK_IO	; FIXED DISK HANDLER
	MOV	WORD PTR ORG_VECTOR+2,CS		;  AT INT 13H
	MOV	AX, OFFSET HD_INT			; FIXED DISK INTERRUPT
	MOV	WORD PTR HDISK_INT,AX			;  HANDLER AT INT 0DH
	MOV	WORD PTR HDISK_INT+2,CS
	MOV	WORD PTR BOOT_VEC,OFFSET BOOT_STRAP	; BOOTSTRAP ROUTINE AT
	MOV	WORD PTR BOOT_VEC+2,CS			;  INT 19H
	MOV	WORD PTR HF_TBL_VEC,OFFSET FD_TBL	; PARAMETER TABLE AT
	MOV	WORD PTR HF_TBL_VEC+2,CS		;  INT 41H
	STI

	ASSUME	DS:DATA
	MOV	AX,DATA			; ESTABLISH SEGMENT
	MOV	DS,AX
	MOV	DISK_STATUS,0		; RESET THE STATUS INDICATOR
	MOV	HF_NUM,0		; ZERO COUNT THE DRIVES
	MOV	PORT_OFF,0		; ZERO CARD OFFSET
	MOV	CX,25H			; RETRY COUNT
L4:
	CALL	HD_RESET_1		; RESET CONTROLLER
	JNC	L7
	LOOP	L4			; TRY RESET AGAIN
	JMP	ERROR_EX
L7:
	MOV	CX,1
	MOV	DX,80H
	MOV	AX,1200H		; CONTROLLER DIAGNOSTICS
	INT	13H			;  CHECK THE INTERNAL RAM
	JNC	P7			;  BUFFERS
	JMP	ERROR_EX
P7:
	MOV	AX,1400H		; CONTROLLER DIAGNOSTICS
	INT	13H			;  INTERNAL CHECKSUM AND
	JNC	P9			;  ECC CIRCUITRY TEST.
	JMP	ERROR_EX
P9:
	MOV	TIMER_LOW,0		; ZERO TIMER
	CMP	RESET_FLAG,1234H	; KEYBOARD RESET
	JNE	P8
	MOV	TIMER_LOW,410D		; SKIP WAIT ON RESET
P8:
	CLI				; DISABLE INTERRUPTS
	IN	AL,INTA01		; TIMER
	AND	AL,0FEH			; ENABLE TIMER
	OUT	INTA01,AL		; START TIMER
	STI				; INTERRUPTS ON
P4:
	CALL	HD_RESET_1		; RESET CONTROLLER
	JC	P10
	MOV	AX,1000H		; TEST TO SEE IF THE DRIVE
	INT	13H			;  IS READY
	JNC	P2
P10:
	MOV	AX,TIMER_LOW
	CMP	AX,446D			; 25 SECONDS
	JB	P4
	JMP	SHORT ERROR_EX
P2:
	MOV	AX,1100H		; RECALIBRATE THE DRIVE 0
	INT	13H
	JC	ERROR_EX

	MOV	AX,0900H		; SET DRIVE PARAMETERS
	INT	13H			;  FOR DRIVE 0
	JC	ERROR_EX

	MOV	AX,0C800H		; DMA TO BUFFER
	MOV	ES,AX			; SET SEGMENT
	SUB	BX,BX
	MOV	AX,0F00H		; WRITE SECTOR BUFFER
	INT	13H
	JC	ERROR_EX

	INC	HF_NUM			; DRIVE ZERO RESPONDED
	MOV	DX,213H			; EXPANSION BOX
	MOV	AL,0
	OUT	DX,AL			; TURN BOX OFF
	MOV	DX,321H			; TEST IF CONTROLLER
	IN	AL,DX			; ... IS IN THE SYSTEM UNIT
	AND	AL,0FH
	CMP	AL,0FH
	JE	BOX_ON
	MOV	TIMER_LOW,420D		; CONTROLLER IS IN SYSTEM UNIT
BOX_ON:
	MOV	DX,213H			; EXPANSION BOX
	MOV	AL,0FFH
	OUT	DX,AL			; TURN BOX ON
	MOV	CX,1			; ATTEMPT NEXT DRIVES
	MOV	DX,081H
P3:
	SUB	AX,AX			; RESET THE CONTROLLER
	INT	13H
	JC	POD_DONE
	MOV	AX,01100H		; RECALIBRATE THE DRIVE 1
	INT	13H
	JNC	P5
	MOV	AX,TIMER_LOW
	CMP	AX,446D			; 25 SECONDS
	JB	P3
	JMP	SHORT POD_DONE
P5:
	MOV	AX,0900H		; INITIALIZE DRIVE CHARACTERISTICS
	INT	13H			;  FOR DRIVE 1
	JC	POD_DONE
	INC	HF_NUM			; TALLY ANOTHER DRIVE
	CMP	DX,(80H + S_MAX_FILE - 1)
	JAE	POD_DONE
	INC	DX
	JMP	P3

F17	DB	'1701',0DH,0AH		; POST MESSAGE
F17L	EQU	$-F17

;----- POD ERROR

ERROR_EX:
	MOV	BP,0FH			; POD ERROR FLAG
	SUB	SI,SI
	MOV	CX,F17L			; MESSAGE CHARACTER COUNT
	MOV	BH,0			; PAGE ZERO
OUT_CH:
	MOV	AL,CS:F17[SI]		; GET BYTE
	MOV	AH,14D			; VIDEO OUT
	INT	10H			; DISPLAY CHARACTER
	INC	SI			; NEXT CHAR
	LOOP	OUT_CH			; DO MORE
	STC
POD_DONE:
	CLI				; NO INTERRUPTS
	IN	AL,021H			; READ THE INTERRUPT MASK
	OR	AL,01H			; DISABLE THE TIMER
	OUT	021H,AL
	STI				; ENABLE INTERRUPTS
	CALL	DSBL			; DISABLE THE CARD MASKS
	RET

HD_RESET_1	PROC	NEAR
	PUSH	CX			; SAVE REGISTER
	PUSH	DS
	MOV	CX,0100H		; RETRY COUNT
L6:
	CALL	PORT_0
	INC	DX			; ADDRESS PORT_1
	OUT	DX,AL			; RESET CARD
	JMP	$+2			; I/O DELAY AT LEAST +5us
	JMP	$+2			; ALLOW TIME TO CLEAR THE
	JMP	$+2			;  HARDWARE STATUS REGISTER
	IN	AL,DX			; READ THE HARDWARE STATUS
	AND	AL,00111111B		; MASK OFF UPPER 2 BITS AND CLEAR CY
	JZ	R3			; EXIT IF REGISTER IS CLEARED WITH CY=0
	LOOP	L6			; TRY AGAIN
	STC				; SET ERROR CONDITION CY=1
R3:
	POP	DX			; RESTORE REGISTER
	POP	CX
	RET
HD_RESET_1	ENDP
DISK_SETUP	ENDP

;---  INT 19 H --------------------------------------------------
;                                                               :
; INTERRUPT 19 BOOT STRAP LOADER                                :
;                                                               :
;  -  THE FIXED DISK BIOS REPLACES THE INTERRUPT 19H BOOT       :
;     STRAP VECTOR WITH A POINTER TO THIS BOOT ROUTINE AND      :
;     RESETS THE DEFAULT DISK AND DISKETTE PARAMETER VECTORS    :
;                                                               :
;  -  THE BOOT BLOCK TO BE READ IN WILL BE ATTEMPTED FROM       :
;     CYLINDER 0 SECTOR 1 OF THE DEVICE.                        :
;                                                               :
;  -  THE BOOTSTRAP SEQUENCE IS:                                :
;       ATTEMPT TO LOAD FROM THE DISKETTE INTO THE BOOT         :
;       LOCATION (0000:7C00H) WHERE CONTROL IS TRANSFERRED.     :
;       IF THE DISKETTE FAILS THE FIXED DISK IS TRIED FOR A     :
;       VALID BOOTSTRAP BLOCK. A VALID BOOT BLOCK ON THE        :
;       FIXED DISK CONSISTS OF THE BYTES  055H 0AAH  AS THE     :
;       LAST TWO BYTES OF THE BLOCK                             :
;       IF THE ABOVE FAILS CONTROL IS PASSED TO RESIDENT BASIC  :
;                                                               :
;----------------------------------------------------------------

BOOT_STRAP:
	ASSUME	DS:ABS0,ES:ABS0
	SUB	AX,AX
	MOV	DS,AX			; ESTABLISH SEGMENT
	MOV	AH,0C0H
	INT	15H			; READ CONFIGURATION PARAMETERS
					; IF XT OR PC, INTERRUPTS ARE DISABLED
;----- RESET PARAMETER VECTORS		; AT THIS POINT.

	CLI
	MOV	WORD PTR HF_TBL_VEC, OFFSET FD_TBL
	MOV	WORD PTR HF_TBL_VEC+2,CS
	JNC	H0			; JMP IF INT 15 FUNCTION IMPLEMENTED

	MOV	WORD PTR DISKETTE_PARM, OFFSET DISKETTE_TBL
	MOV	WORD PTR DISKETTE_PARM+2,CS
H0:
	STI

;----- ATTEMPT BOOTSTRAP FROM DISKETTE

	SUB	DX,DX			; DRIVE ZERO

;----- ESTABLISH ES:BX POINTER

	MOV	ES,DX			; ESTABLISH SEGMENT
	MOV	BX,OFFSET BOOT_LOCN	; SET BX TO 7C00H

;----- CLEAR BOOT_LOCN

	CLD				; DIRECTION FORWARD
	XOR	AX,AX
	MOV	CX,256			; CLEAR 256 WORDS
	MOV	DI,BX			; POINT TO BOOT LOCATION BUFFER
	REP	STOSW			; ZERO THE BOOT LOCATION BUFFER

	MOV	CX,4			; SET RETRY COUNT
H1:					; IPL_SYSTEM
	PUSH	CX			; SAVE RETRY COUNT
	SUB	AX,AX			; RESET THE DISKETTE
	INT	13H			; FILE IO CALL
	JC	H2			; IF ERROR, TRY AGAIN

	MOV	AX,0201H		; READ IN THE SINGLE SECTOR
	MOV	CX,1			; SECTOR 1, TRACK 0
	INT	13H			; FILE IO CALL
H2:	POP	CX			; RECOVER RETRY COUNT
	JNC	H3			; CARRY FLAG SET BY UNSUCCESSFUL READ

	CMP	AH,80H			; IF TIME OUT, NO RETRY
	JZ	H6			; TRY FIXED DISK

	LOOP	H1			; DO IT FOR RETRY TIMES
	JMP	SHORT H6		; UNABLE TO IPL FROM THE DISKETTE

H3:	CMP	BYTE PTR BOOT_LOCN,06H	; CHECK FOR FIRST INSTRUCTION INVALID
	JB	H10			; IF BOOT NOT VALID, GO TO BASIC

;-----  INSURE DATA PATTERN FIRST 8 WORDS NOT ALL EQUAL

	MOV	DI,OFFSET BOOT_LOCN	; CHECK DATA PATTERN
	MOV	CX,8			; CHECK THE NEXT 8 WORDS
	MOV	AX,WORD PTR BOOT_LOCN	; LOAD THE FIRST WORD

H4:	ADD	DI,2			; POINT TO NEXT WORD
	CMP	AX,[DI]			; CHECK DATA PATTERN FOR A FILL PATTERN
	LOOPZ	H4
	JZ	H10			; BOOT NOT VALID, GO TO BASIC
H5:
	JMP	BOOT_LOCN

;----- ATTEMPT BOOTSTRAP FROM FIXED DISK

H6:
	SUB	AX,AX			; RESET DISKETTE
	INT	13H
	MOV	CX,3			; SET RETRY COUNT
	MOV	DX,0080H		; FIXED DISK ZERO
H7:					; IPL_SYSTEM
	PUSH	CX			; SAVE RETRY COUNT
	SUB	AX,AX			; RESET THE FIXED DISK
	INT	13H			; FILE IO CALL
	JC	H8			; IF ERROR, TRY AGAIN

;-----  ES AND BX ALREADY ESTABLISHED

	MOV	AX,0201H		; READ IN THE SINGLE SECTOR
	MOV	CX,1			; SECTOR 1, TRACK 0
	INT	13H			; FILE IO CALL
H8:	POP	CX			; RECOVER RETRY COUNT
	JC	H9
	MOV	AX,WORD PTR BOOT_LOCN+510D
	CMP	AX,0AA55H		; TEST FOR GENERIC BOOT BLOCK
	JZ	H5			; GO TO BOOT LOCATION
H9:
	LOOP	H7			; DO IT FOR RETRY TIMES

;------ UNABLE TO IPL FROM THE DISKETTE OR FIXED DISK

H10:
	INT	18H			; RESIDENT BASIC

DISKETTE_TBL:

	DB	11001111B		; SRT=C, HD UNLOAD=0F - 1ST SPEC BYTE
	DB	2			; HD LOAD=1, MODE=DMA - 2ND SPEC BYTE
	DB	25H			; WAIT AFTER OPN TIL MOTOR OFF
	DB	2			; 512 BYTES PER SECTOR
	DB	8			; EOT (LAST SECTOR ON TRACK)
	DB	02AH			; GAP LENGTH
	DB	0FFH			; DTL
	DB	050H			; GAP LENGTH FOR FORMAT
	DB	0F6H			; FILL BYTE FOR FORMAT
	DB	25			; HEAD SETTLE TIME (MILLISECONDS)
	DB	4			; MOTOR START TIME (1/8 SECOND)

;----- MAKE SURE THAT ALL HOUSEKEEPING IS DONE BEFORE EXIT

DSBL	PROC	NEAR
	SUB	AL,AL			; RESET INT/DMA MASK
	MOV	DX,HF_PORT+3		; LOAD FOR PORT ADDRESS 3
	CLI				; DISABLE INTERRUPTS
	OUT	DX,AL			; RESET INT/DMA MASK CARD 0
	ADD	DX,4
	OUT	DX,AL			; RESET INT/DMA MASK CARD 1
	ADD	DX,4
	OUT	DX,AL			; RESET INT/DMA MASK CARD 2
	ADD	DX,4
	OUT	DX,AL			; RESET INT/DMA MASK CARD 3

	MOV	AL,07H
	OUT	DMA+10,AL		; SET DMA MODE TO DISABLE
	IN	AL,INTA01
	OR	AL,020H
	OUT	INTA01,AL		; DISABLE IREQ 5
	STI				; ENABLE INTERRUPTS
	RET
DSBL	ENDP

;---  DISK_IO  ------------------------------------------
;               FIXED DISK BIOS ENTRY POINT             :
;--------------------------------------------------------

DISK_IO	PROC	FAR
	ASSUME	DS:DATA,ES:NOTHING
	CMP	DL,80H			; TEST FOR FIXED DISK DRIVE
	JAE	HARD_DISK		; YES, HANDLE HERE
	INT	40H			; DISKETTE HANDLER
RET_2:
	RET	2			; BACK TO CALLER

HARD_DISK:
	STI				; ENABLE INTERRUPTS
	OR	AH,AH
	JNZ	A3
	INT	40H			; RESET NEC WHEN AH=0
	SUB	AH,AH
	CMP	DL,(80H+S_MAX_FILE-1)	; DL IN LIMITS?
	JA	RET_2
A3:
	CMP	AH,8			; GET PARAMETERS IS A SPECIAL CASE
	JNZ	A2
	JMP	GET_PARM_N
A2:
	PUSH	BP			; SAVE THE BASE POINTER
	MOV	BP,SP			; LOAD THE CMD_BLOCK POINTER
	SUB	SP,8			; ALLOCATE SPACE FOR THE COMMAND BLOCK
					;  ON THE STACK.
	PUSH	BX			; SAVE REGISTERS DURING OPERATION
	PUSH	CX
	PUSH	DX
	PUSH	DS
	PUSH	ES
	PUSH	SI
	PUSH	DI
	MOV	SI,DATA
	MOV	DS,SI			; ESTABLISH DATA SEGMENT

	CALL	DISK_IO_CONT		; PERFORM THE OPERATION

	PUSH	AX
	CALL	DSBL			; BE SURE DISABLES OCCURRED
	MOV	AX,DATA
	MOV	DS,AX			; ESTABLISH SEGMENT
	POP	AX			; RESTORE REGISTERS
	MOV	AH,DISK_STATUS		; GET STATUS FROM OPERATION
	POP	DI			; RESTORE REGISTERS
	POP	SI
	POP	ES
	POP	DS
	POP	DX
	POP	CX
	POP	BX

	ADD	SP,8			; ADJUST THE COMMAND BLOCK.
	POP	BP			; RESTORE BASE POINTER
	CMP	AH,1			; SET THE CARRY FLAG TO INDICATE
	CMC				;  SUCCESS OR FAILURE
	RET	2			; THROW AWAY SAVED FLAGS
DISK_IO	ENDP

M1	LABEL	WORD			; FUNCTION TRANSFER TABLE
	DW	DISK_RESET		; 000H
	DW	RETURN_STATUS		; 001H
	DW	DISK_READ		; 002H
	DW	DISK_WRITE		; 003H
	DW	DISK_VERF		; 004H
	DW	FMT_TRK			; 005H
	DW	FMT_BAD			; 006H
	DW	FMT_DRV			; 007H
	DW	BAD_COMMAND		; 008H
	DW	INIT_DRV		; 009H
	DW	RD_LONG			; 00AH
	DW	WR_LONG			; 00BH
	DW	DISK_SEEK		; 00CH
	DW	DISK_RESET		; 00DH
	DW	RD_BUFF			; 00EH
	DW	WR_BUFF			; 00FH
	DW	TST_RDY			; 010H
	DW	HDISK_RECAL		; 011H
	DW	RAM_DIAG		; 012H
	DW	CHK_DRV			; 013H
	DW	CNTLR_DIAG		; 014H
M1L	EQU	$-M1

DISK_IO_CONT	PROC	NEAR
	CMP	AH,01H			; RETURN STATUS
	JE	RETURN_STATUS

	SUB	DL,080H			; CONVERT DRIVE NUMBER TO A 0 BASED RANGE
	CMP	DL,MAX_FILE		; LEGAL DRIVE TEST
	JAE	BAD_COMMAND

	MOV	DISK_STATUS,0		; RESET THE STATUS INDICATOR

;-----  SET UP COMMAND BLOCK

	DEC	CL			; SECTORS 0-16 FOR CONTROLLER
	MOV	CMD_BLOCK+0,0		; SET TO ZERO THE OP CODE
	MOV	CMD_BLOCK+2,CL		; SECTOR AND HIGH 2 BITS CYLINDER
	MOV	CMD_BLOCK+3,CH		; CYLINDER LOW
	MOV	CMD_BLOCK+4,AL		; INTERLEAVE / BLOCK COUNT
	MOV	AL,CONTROL_BYTE		; CONTROL BYTE (STEP OPTION)
	MOV	CMD_BLOCK+5,AL		; SET THE CONTROL FIELD

;-----  CALCULATE THE PORT OFFSET
	MOV	CH,DL			; SAVE DL
	OR	DL,1
	DEC	DL
	SHL	DL,1			; GENERATE OFFSET
	MOV	PORT_OFF,DL		; STORE OFFSET
	MOV	DL,CH			; RESTORE DL
	AND	DL,1			; MAKE DRIVE 0 OR 1
	MOV	CL,5			; SHIFT COUNT
	SHL	DL,CL			; DRIVE NUMBER (0,1)
	OR	DL,DH			; HEAD NUMBER
	MOV	CMD_BLOCK+1,DL		; SET THE DRIVE AND HEAD

	MOV	CX,AX			; CALCULATE JUMP ADDRESS
	MOV	CL,CH			; GET INTO LOW BYTE
	XOR	CH,CH			; ZERO HIGH BYTE
	SAL	CX,1			; *2 FOR TABLE LOOKUP
	MOV	SI,CX			; PUSH INTO SI FOR BRANCH
	CMP	CX,M1L			; TEST WITHIN RANGE
	JNB	BAD_COMMAND
	JMP	WORD PTR CS:[SI + OFFSET M1]	; GO DO THE COMMAND
BAD_COMMAND:
	MOV	DISK_STATUS,BAD_CMD	; SET BAD COMMAND ERROR
	MOV	AL,0
	RET				; EXIT
DISK_IO_CONT	ENDP

;--------------------------------------------------------
;       RESET THE DISK SYSTEM               (AH = 000H) :
;--------------------------------------------------------

DISK_RESET	PROC	NEAR
	CALL	PORT_0			; RESET PORT
	INC	DX			; PORT_1 ADDRESS
	OUT	DX,AL			; ISSUE RESET
	JMP	$+2			; I/O DELAY AT LEAST 5us
	JMP	$+2			; ALLOW TIME TO CLEAR THE
	JMP	$+2			;  HARDWARE STATUS REGISTER
	IN	AL,DX			; GET STATUS
	AND	AL,00111111B		; MASK OFF UPPER 2 BITS AND CLEAR CY
	JZ	DR1			; EXIT IF REGISTER IS CLEARED WITH CY=0
	MOV	DISK_STATUS,BAD_RESET	; SET THE ERROR CONDITION
	RET				; EXIT
DR1:
	JMP	INIT_DRV		; SET THE DRIVE PARAMETERS

DISK_RESET	ENDP

;--------------------------------------------------------
;       DISK STATUS ROUTINE                 (AH = 001H) :
;--------------------------------------------------------

RETURN_STATUS	PROC	NEAR
	MOV	AL,DISK_STATUS		; OBTAIN PREVIOUS STATUS
	MOV	DISK_STATUS,0		; RESET STATUS
	RET
RETURN_STATUS	ENDP

;--------------------------------------------------------
;       DISK READ ROUTINE                   (AH = 002H) :
;--------------------------------------------------------

DISK_READ	PROC	NEAR
	MOV	AL,DMA_READ		; MODE BYTE FOR DMA READ
	MOV	CMD_BLOCK+0,READ_CMD
	JMP	DMA_OPN
DISK_READ	ENDP

;--------------------------------------------------------
;       DISK WRITE ROUTINE                  (AH = 003H) :
;--------------------------------------------------------

DISK_WRITE	PROC	NEAR
	MOV	AL,DMA_WRITE		; MODE BYTE FOR DMA WRITE
	MOV	CMD_BLOCK+0,WRITE_CMD
	JMP	DMA_OPN
DISK_WRITE	ENDP

;--------------------------------------------------------
;       DISK VERIFY                         (AH = 004H) :
;--------------------------------------------------------

DISK_VERF	PROC	NEAR
	MOV	CMD_BLOCK+0,CHK_TRK_CMD
	JMP	NDMA_OPN
DISK_VERF	ENDP

;--------------------------------------------------------
;       FORMATTING                (AH = 005H 006H 007H) :
;--------------------------------------------------------

FMT_TRK	PROC	NEAR			; FORMAT TRACK  (AH = 005H)
	MOV	CMD_BLOCK,FMTTRK_CMD
	JMP	SHORT	FMT_CONT
FMT_TRK	ENDP

FMT_BAD	PROC	NEAR			; FORMAT BAD TRACK  (AH = 006H)
	MOV	CMD_BLOCK,FMTBAD_CMD
	JMP	SHORT	FMT_CONT
FMT_BAD	ENDP

FMT_DRV	PROC	NEAR			; FORMAT DRIVE  (AH = 007H)
	MOV	CMD_BLOCK,FMTDRV_CMD
FMT_DRV	ENDP

FMT_CONT:
	AND	CMD_BLOCK+2,11000000B	; ZERO OUT SECTOR FIELD
	JMP	NDMA_OPN

;--------------------------------------------------------
;       GET PARAMETERS                         (AH = 8) :
;--------------------------------------------------------

GET_PARM_N	LABEL	NEAR
GET_PARM	PROC	FAR		; GET DRIVE PARAMETERS
	PUSH	DS			; SAVE REGISTERS
	PUSH	ES
	PUSH	BX

	ASSUME	DS:ABS0
	SUB	AX,AX			; ESTABLISH ADDRESSING
	MOV	DS,AX
	LES	BX,HF_TBL_VEC

	ASSUME	DS:DATA
	MOV	AX,DATA
	MOV	DS,AX			; ESTABLISH SEGMENT
	SUB	DL,80H
	CMP	DL,MAX_FILE		; TEST WITHIN RANGE
	JAE	G4
	MOV	DISK_STATUS,0		; RESET THE STATUS INDICATOR
	MOV	DH,DL			; SAVE THE DRIVE
	OR	DL,1
	DEC	DL
	SHL	DL,1			; GENERATE OFFSET
	MOV	PORT_OFF,DL		; STORE OFFSET
	MOV	DL,CH			; RESTORE DL
	AND	DL,00000001B		; DRIVE 0 OR DRIVE 1
	MOV	AH,DL
	CALL	PORT_0
	INC	DX			; PORT_2 ADDRESS
	INC	DX
	IN	AL,DX			; READ SWITCH SETTINGS
	CMP	AH,0			; DRIVE 0 OR 1
	JNZ	G0
	SHR	AL,1			; RIGHT JUSTIFY THE SWITCH BITS
	SHR	AL,1
G0:
	AND	AL,00000011B		; ISOLATE THE TABLE BITS
	MOV	CL,4			; TABLE LENGTH IS 16 BYTES
	SHL	AL,CL			; ADJUST
	SUB	AH,AH
	ADD	BX,AX
	MOV	AX,ES:[BX]		; MAX NUMBER OF CYLINDERS
	SUB	AX,2			; ADJUST FOR 0-N
					; AND RESERVE LAST TRACK
	MOV	CH,AL
	AND	AX,0300H		; HIGH TWO BITS OF CYL
	SHR	AX,1
	SHR	AX,1
	OR	AL,011H			; SECTORS
	MOV	CL,AL
	MOV	DH,ES:[BX][2]		; HEADS
	DEC	DH			; 0-N RANGE
	MOV	DL,HF_NUM		; DRIVE COUNT
	SUB	AX,AX
G5:
	POP	BX			; RESTORE REGISTERS
	POP	ES
	POP	DS
	RET	2
G4:
	MOV	DISK_STATUS,INIT_FAIL	; OPERATION FAILED
	MOV	AH,INIT_FAIL
	SUB	AL,AL
	SUB	DX,DX
	SUB	CX,CX
	STC				; SET ERROR FLAG
	JMP	G5			; EXIT
GET_PARM	ENDP

;--------------------------------------------------------
; INITIALIZE DRIVE CHARACTERISTICS                      :
;                                                       :
; FIXED DISK PARAMETER TABLE                            :
;                                                       :
;  -  THE TABLE IS COMPOSED OF A BLOCK DEFINED AS:      :
;                                                       :
;       (1 WORD) - MAXIMUM NUMBER OF CYLINDERS          :
;       (1 BYTE) - MAXIMUM NUMBER OF HEADS              :
;       (1 WORD) - STARTING REDUCED WRITE CURRENT CYL   :
;       (1 WORD) - STARTING WRITE PRECOMPENSATION CYL   :
;       (1 BYTE) - MAXIMUM ECC DATA BURST LENGTH        :
;       (1 BYTE) - CONTROL BYTE (DRIVE STEP OPTION)     :
;                  BIT    7 DISABLE DISK-ACCESS RETRIES :
;                  BIT    6 DISABLE ECC RETRIES         :
;                  BITS 5-3 ZERO                        :
;                  BITS 2-0 DRIVE OPTION                :
;       (1 BYTE) - STANDARD TIME OUT VALUE (SEE BELOW)  :
;       (1 BYTE) - TIME OUT VALUE FOR FORMAT DRIVE      :
;       (1 BYTE) - TIME OUT VALUE FOR CHECK DRIVE       :
;       (1 WORD) - LANDING ZONE                         :
;       (1 BYTE) - SECTORS/TRACK                        :
;       (1 BYTE) - RESERVED FOR FUTURE USE              :
;                                                       :
;       - TO DYNAMICALLY DEFINE A SET OF PARAMETERS     :
;         BUILD A TABLE OF VALUES AND PLACE THE         :
;         CORRESPONDING VECTOR INTO INTERRUPT 41.       :
;                                                       :
;      NOTE:                                            :
;              THE DEFAULT TABLE IS VECTORED IN FOR     :
;              AN INTERRUPT 19H (BOOTSTRAP)             :
;                                                       :
;                                                       :
; ON THE CARD SWITCH SETTINGS                           :
;                                                       :
;                 DRIVE 0    DRIVE 1                    :
;               -----------------------                 :
;         ON    :          /          :                 :
;               : -1-  -2- / -3-  -4- :                 :
;         OFF   :          /          :                 :
;               -----------------------                 :
;                                                       :
;                                                       :
;       TRANSLATION TABLE                               :
;                                                       :
;       DRIVE 0  :  DRIVE 1  :  TABLE ENTRY             :
;         1/2    :    3/4    :                          :
;       -----------------------------------             :
;        ON ON   :   ON ON   :       0                  :
;        ON OFF  :   ON OFF  :       1                  :
;        OFF ON  :   OFF ON  :       2                  :
;        OFF OFF :   OFF OFF :       3                  :
;                                                       :
;--------------------------------------------------------

FD_TBL:

;----- DRIVE TYPE 0

	DW	0306D			; MAX CYLINDERS
	DB	04D			; MAX HEADS
	DW	0306D			; START REDUCED WRITE CURRENT CYL
	DW	0			; START WRITE PRECOMPENSATION CYL
	DB	0BH			; MAX ECC BURST DATA LENGTH
	DB	00000101B		; CONTROL BYTE
	DB	010H			; STANDARD TIME OUT
	DB	0C0H			; TIME OUT FOR FORMAT DRIVE
	DB	028H			; TIME OUT FOR CHECK DRIVE
	DW	0306D			; LANDING ZONE
	DB	017D			; SECTORS/TRACK
	DB	0			; RESERVED

;----- DRIVE TYPE 1

	DW	0612D			; MAX CYLINDERS
	DB	04D			; MAX HEADS
	DW	0612D			; START REDUCED WRITE CURRENT CYL
	DW	0			; START WRITE PRECOMPENSATION CYL
	DB	0BH			; MAX ECC BURST DATA LENGTH
	DB	00000101B		; CONTROL BYTE
	DB	028H			; STANDARD TIME OUT
	DB	0E0H			; TIME OUT FOR FORMAT DRIVE
	DB	042H			; TIME OUT FOR CHECK DRIVE
	DW	0663D			; LANDING ZONE
	DB	017D			; SECTORS/TRACK
	DB	0			; RESERVED

;----- DRIVE TYPE 2

	DW	0615D			; MAX CYLINDERS
	DB	04D			; MAX HEADS
	DW	0615D			; START REDUCED WRITE CURRENT CYL
	DW	0300D			; START WRITE PRECOMPENSATION CYL
	DB	0BH			; MAX ECC BURST DATA LENGTH
	DB	00000101B		; CONTROL BYTE
	DB	028H			; STANDARD TIME OUT
	DB	0E0H			; TIME OUT FOR FORMAT DRIVE
	DB	042H			; TIME OUT FOR CHECK DRIVE
	DW	0615D			; LANDING ZONE
	DB	017D			; SECTORS/TRACK
	DB	0			; RESERVED

;----- DRIVE TYPE 3

	DW	0306D			; MAX CYLINDERS
	DB	08D			; MAX HEADS
	DW	0306D			; START REDUCED WRITE CURRENT CYL
	DW	0128D			; START WRITE PRECOMPENSATION CYL
	DB	0BH			; MAX ECC BURST DATA LENGTH
	DB	00000101B		; CONTROL BYTE
	DB	028H			; STANDARD TIME OUT
	DB	0E0H			; TIME OUT FOR FORMAT DRIVE
	DB	042H			; TIME OUT FOR CHECK DRIVE
	DW	0336D			; LANDING ZONE
	DB	017D			; SECTORS/TRACK
	DB	0			; RESERVED

;--------------------------------------------------------
;       INITIALIZE DRIVE                     (AH = 09H) :
;--------------------------------------------------------

INIT_DRV	PROC	NEAR

;----- DO DRIVE ZERO

	MOV	CMD_BLOCK+0,INIT_DRV_CMD
	MOV	CMD_BLOCK+1,0		; SET FOR DRIVE 0
	CALL	INIT_DRV_R		; SEND THE PARAMETERS
	JC	INIT_DRV_OUT		; ERROR?

;----- DO DRIVE ONE

	MOV	CMD_BLOCK+0,INIT_DRV_CMD
	MOV	CMD_BLOCK+1,00100000B	; SET TO DRIVE 1
	CALL	INIT_DRV_R		; SENT THE PARAMETERS
INIT_DRV_OUT:
	RET
INIT_DRV	ENDP

INIT_DRV_R	PROC	NEAR
	SUB	AL,AL
	CALL	COMMAND			; ISSUE THE COMMAND
	JNC	B1			;  DX = PORT 0 AFTER CALL
	RET
B1:
	MOV	CX,DS			; SAVE SEGMENT

	ASSUME	DS:ABS0
	SUB	AX,AX
	MOV	DS,AX			; ESTABLISH SEGMENT
	LES	BX,HF_TBL_VEC		; LOAD THE TABLE VECTOR
	MOV	DS,CX			; RESTORE SEGMENT

	ASSUME	DS:DATA
;------------------------------------------------
;       DETERMINE PARAMETER TABLE OFFSET        :
;       USING CONTROLLER PORT TWO AND           :
;       DRIVE NUMBER SPECIFIER (0-1)            :
;------------------------------------------------
	INC	DX
	INC	DX			; ADDRES PORT 2
	IN	AL,DX			; READ THE SWITCH SETTINGS
	MOV	AH,CMD_BLOCK+1
	AND	AH,00100000B		; DRIVE 0 OR 1
	JNZ	B2
	SHR	AL,1			; ADJUST
	SHR	AL,1
B2:
	AND	AL,011B			; ISOLATE
	MOV	CL,4
	SHL	AL,CL			; ADJUST
	SUB	AH,AH
	ADD	BX,AX
	MOV	AH,00001001B		; SET MASK FOR DATA MODE CPU TO CARD

;-----  SEND DRIVE PARAMETERS MOST SIGNIFICANT BYTE FIRST

	MOV	DI,1			; SEND MSB OF MAX CYLINDER
	CALL	INIT_DRV_S
	JC	B3

	MOV	DI,0			; SEND LSB OF MAX CYLINDER
	CALL	INIT_DRV_S
	JC	B3

	MOV	DI,2			; SEND THE MAXIMUM HEADS
	CALL	INIT_DRV_S
	JC	B3

	MOV	DI,4			; SEND MSB OF REDUCE WRITE CURRENT
	CALL	INIT_DRV_S		;  CYLINDER
	JC	B3

	MOV	DI,3			; SEND LSB OF REDUCE WRITE CURRENT
	CALL	INIT_DRV_S		;  CYLINDER
	JC	B3

	MOV	DI,6			; SEND MSB OF WRITE PRECOMP CYLINDER
	CALL	INIT_DRV_S
	JC	B3

	MOV	DI,5			; SEND LSB OF WRITE PRECOMP CYLINDER
	CALL	INIT_DRV_S
	JC	B3

	MOV	DI,7			; SEND ECC BURST LENGTH
	CALL	INIT_DRV_S
	JC	B3

	MOV	DI,8			; LOAD THE CONTROL BYTE AND PLACE IN
	MOV	AL,ES:[BX + DI]		;  MEMORY AT 40:76H
	MOV	CONTROL_BYTE,AL

	SUB	CX,CX
	MOV	AH,00001111B		; SET THE MASK FOR STATUS MODE
B5:
	CALL	HD_WAIT			; GO WAIT FOR THE STATE TO HAPPEN
	JNC	B6			; JMP TO READ THE STATUS BYTE
	LOOP	B5			; TRY AGAIN
B3:
	MOV	DISK_STATUS,INIT_FAIL	; OPERATION FAILED
	STC				; SET THE ERROR CONDITION
	RET
B6:
	DEC	DX			; ADDRESS PORT 0
	IN	AL,DX			; READ STATUS BYTE OF THE OPERATION
	AND	AL,2			; MASK ERROR BIT
	JNZ	B3			; ERROR BIT SET?
	RET
INIT_DRV_R	ENDP

;-----  SEND THE BYTE OUT TO THE CONTROLLER

INIT_DRV_S	PROC	NEAR
	CALL	HD_WAIT			; GO WAIT FOR REQUEST
	JC	D1			;  AFTER CALL DX = PORT 1
	DEC	DX			; ADDRESS PORT 0
	MOV	AL,ES:[BX + DI]
	OUT	DX,AL			; WRITE DATA TO THE CARD
D1:
	RET
INIT_DRV_S	ENDP

;--------------------------------------------------------
;       READ LONG                            (AH = 0AH) :
;--------------------------------------------------------

RD_LONG		PROC	NEAR
	CALL	CHK_LONG		; CHECK LIMITS
	JC	G8
	MOV	CMD_BLOCK+0,RD_LONG_CMD
	MOV	AL,DMA_READ
	JMP	SHORT	DMA_OPN
RD_LONG		ENDP

;--------------------------------------------------------
;       WRITE LONG                           (AH = 0BH) :
;--------------------------------------------------------

WR_LONG		PROC	NEAR
	CALL	CHK_LONG		; CHECK LIMITS
	JC	G8
	MOV	CMD_BLOCK+0,WR_LONG_CMD
	MOV	AL,DMA_WRITE
	JMP	SHORT	DMA_OPN
WR_LONG	ENDP

CHK_LONG	PROC	NEAR
	MOV	AL,CMD_BLOCK+4		; LOAD THE NUMBER OF SECTORS
	CMP	AL,080H			; COMPARE WITH LIMITS
	CMC				; SET THE CONDITION
	RET
CHK_LONG	ENDP

;--------------------------------------------------------
;       SEEK                                 (AH = 0CH) :
;--------------------------------------------------------

DISK_SEEK	PROC	NEAR
	MOV	CMD_BLOCK+0,SEEK_CMD
	JMP	SHORT	NDMA_OPN
DISK_SEEK	ENDP

;--------------------------------------------------------
;       READ SECTOR BUFFER                   (AH = 0EH) :
;--------------------------------------------------------

RD_BUFF	PROC	NEAR
	MOV	CMD_BLOCK+0,RD_BUFF_CMD
	MOV	CMD_BLOCK+4,1		; ONLY ONE BLOCK
	MOV	AL,DMA_READ
	JMP	SHORT	DMA_OPN
RD_BUFF	ENDP

;--------------------------------------------------------
;       WRITE SECTOR BUFFER                  (AH = 0FH) :
;--------------------------------------------------------

WR_BUFF	PROC	NEAR
	MOV	CMD_BLOCK+0,WR_BUFF_CMD
	MOV	CMD_BLOCK+4,1		; ONLY ONE BLOCK
	MOV	AL,DMA_WRITE
	JMP	SHORT	DMA_OPN
WR_BUFF	ENDP

;--------------------------------------------------------
;       TEST DISK READY                     (AH = 010H) :
;--------------------------------------------------------

TST_RDY	PROC	NEAR
	MOV	CMD_BLOCK+0,TST_RDY_CMD
	JMP	SHORT	NDMA_OPN
TST_RDY	ENDP

;--------------------------------------------------------
;       RECALIBRATE                         (AH = 011H) :
;--------------------------------------------------------

HDISK_RECAL	PROC	NEAR
	MOV	CMD_BLOCK,RECAL_CMD
	JMP	SHORT	NDMA_OPN
HDISK_RECAL	ENDP

;--------------------------------------------------------
;       CONTROLLER RAM DIAGNOSTICS          (AH = 012H) :
;--------------------------------------------------------

RAM_DIAG	PROC	NEAR
	MOV	CMD_BLOCK+0,RAM_DIAG_CMD
	JMP	SHORT	NDMA_OPN
RAM_DIAG	ENDP

;--------------------------------------------------------
;       DRIVE DIAGNOSTICS                   (AH = 013H) :
;--------------------------------------------------------

CHK_DRV	PROC	NEAR
	MOV	CMD_BLOCK+0,CHK_DRV_CMD
	JMP	SHORT	NDMA_OPN
CHK_DRV	ENDP

;--------------------------------------------------------
;      CONTROLLER INTERNAL DIAGNOSTICS      (AH = 014H) :
;--------------------------------------------------------

CNTLR_DIAG	PROC	NEAR
	MOV	CMD_BLOCK+0,CNTLR_DIAG_CMD
CNTLR_DIAG	ENDP

;--------------------------------------------------------
;                   SUPPORT ROUTINES                    :
;--------------------------------------------------------

NDMA_OPN:
	MOV	AL,02H
	CALL	COMMAND			; ISSUE THE COMMAND
	JC	G11
	JMP	SHORT	G3
G8:
	MOV	DISK_STATUS,DMA_BOUNDARY
	RET
DMA_OPN:
	CALL	DMA_SETUP		; SET UP FOR DMA OPERATION
	JC	G8
	MOV	AL,03H
	CALL	COMMAND			; ISSUE THE COMMAND
	JC	G11
	MOV	AL,03H
	OUT	DMA+10,AL		; INITIALIZE THE DISK CHANNEL
G3:
	CLI				; NO INTERRUPTS
	IN	AL,INTA01		; READ THE MASK
	AND	AL,0DFH			; ENABLE IRQ-5
	OUT	INTA01,AL		; WRITE THE MASK OUT
	CALL	WAIT_INT		; PROCEDURE DOES STI
G11:
	CALL	ERROR_CHK		; SEE IF THERE IS AN ERROR
	RET				; EXIT

;--------------------------------------------------------
; COMMAND                                               :
;       THIS ROUTINE OUTPUTS THE COMMAND BLOCK          :
; INPUT                                                 :
;       AL = CONTROLLER DMA/INTERRUPT REGISTER MASK     :
;                                                       :
;--------------------------------------------------------

COMMAND	PROC	NEAR
	CALL	PORT_0			; GET THE BASE ADDRESS
	INC	DX
	INC	DX			; ADDRESS PORT 2
	OUT	DX,AL			; ISSUE CONTROLLER SELECT PULSE
	INC	DX			; ADDRESS PORT 3
	OUT	DX,AL			; WRITE DMA MASK REGISTER
	DEC	DX
	DEC	DX			; ADDRES PORT 1
WAIT_BUSY:
	IN	AL,DX			; READ THE HARDWARE STATUS
	AND	AL,0FH
	CMP	AL,R1_BUSY OR R1_BUS OR R1_REQ	; CHECK FOR BUSY,COMMAND
	JE	C1				; AND REQUEST BITS
	LOOP	WAIT_BUSY		; KEEP TRYING
	MOV	DISK_STATUS,TIME_OUT
	STC				; SET THE ERROR CONDITION
	RET				; ERROR RETURN
C1:
	MOV	CX,6			; SET FOR 6 BYTES OF COMMAND
	DEC	DX			; ADDRESS PORT 0
	MOV	SI,BP			; SAVE THE BASE POINTER
	SUB	BP,8			; SET FIRST BYTE OF COMMAND BLOCK
	CLI				; NO INTERRUPTS IN COMMAND SEQUENCE
CM3:
	MOV	AL,[BP]			; GET A COMMAND BYTE
	OUT	DX,AL			; ALLOW AT LEAST 2us BETWEEN EACH BYTE
	INC	BP			;  ON SENDING THE COMMAND SEQUENCE.
	LOOP	CM3			; DO MORE
	MOV	BP,SI			; RESTORE THE BASE POINTER
	STI				; INTERRUPTS BACK ON
	RET
COMMAND	ENDP

;------------------------------------------------
;               SENSE STATUS BYTES              :
;                                               :
; BYTE 0                                        :
;       BIT    7   ADDRESS VALID, WHEN SET      :
;       BIT    7   SPARE, SET TO ZERO           :
;       BITS 5-4   ERROR TYPE                   :
;       BITS 3-0   ERROR CODE                   :
;                                               :
; BYTE 1                                        :
;       BITS 7-6   ZERO                         :
;       BIT    5   DRIVE (0-1)                  :
;       BITS 4-0   HEAD NUMBER                  :
;                                               :
; BYTE 2                                        :
;       BITS 7-5   CYLINDER HIGH                :
;       BITS 4-0   SECTOR NUMBER                :
;                                               :
; BYTE 3                                        :
;       BITS 7-0   CYLINDER LOW                 :
;                                               :
;------------------------------------------------

ERROR_CHK	PROC	NEAR
	MOV	AL,DISK_STATUS		; CHECK IF THERE WAS AN ERROR
	OR	AL,AL			; ANYTHING IN AL?
	JNZ	G21
	RET

;--------------------------------
;     PERFORM SENSE STATUS      :
;--------------------------------
					; SENSE STATUS CAN BE ISSUES MULTIPLE
					;  TIMES
G21:
	MOV	CMD_BLOCK+0,SENSE_CMD
	SUB	AL,AL			; WRITE 0 IN INT/DMA MASK
	CALL	COMMAND			; ISSUE SENSE STATUS COMMAND
	JC	G24			; CANNOT RECOVER-EXIT WITH COMMAND
					;  ERROR
	SUB	DI,DI			; SET INDEX POINTER TO ZERO
	MOV	CX,4			; READ 4 BYTES
	MOV	AH,00001011B		; SET MASK FOR DATA MODE CARD TO CPU
G22:
	CALL	HD_WAIT			; GO WAIT FOR DATA INPUT STATE
	JC	G24
	DEC	DX			; ADDRESS PORT 0
	IN	AL,DX			; READ THE DATA BYTES
	MOV	[DI+CMD_BLOCK],AL	; STORE AWAY SENSE BYTES
	INC	DI			; NEXT DATA LOCATION
	LOOP	G22			; LOOP TILL ALL FOUR READ.
	CALL	HD_WAIT			; GO WAIT FOR STATUS BYTE
	JC	G24
	DEC	DX			; ADDRESS PORT 0
	IN	AL,DX			; READ THE STATUS BYTE
	TEST	AL,2			; SENSE OPERATION FAIL?
	JZ	STAT_ERR		; GO GET THE ERROR.

	MOV	DISK_STATUS,SENSE_FAIL	; SET SENSE OPERATION FAIL
G24:
	STC
	RET
ERROR_CHK	ENDP

T_0	DW	TYPE_0			; ERROR TYPE JUMP TABLE
T_1	DW	TYPE_1
T_2	DW	TYPE_2
T_3	DW	TYPE_3

STAT_ERR:
	MOV	BL,CMD_BLOCK+0		; GET ERROR BYTE
	MOV	AL,BL
	AND	AL,0FH
	AND	BL,00110000B		; ISOLATE THE TYPE OF ERROR
	SUB	BH,BH
	MOV	CL,3
	SHR	BX,CL			; ADJUST
	JMP	WORD PTR CS:[BX + OFFSET T_0]

TYPE0_TABLE	LABEL	BYTE
	DB	0,BAD_CNTLR,BAD_SEEK,WRITE_FAULT,TIME_OUT,0,BAD_CNTLR
	DB	0,BAD_SEEK
TYPE0_LEN	EQU	$-TYPE0_TABLE

TYPE1_TABLE	LABEL	BYTE
	DB	RECORD_NOT_FND,BAD_ECC,BAD_ADDR_MARK,0,RECORD_NOT_FND
	DB	BAD_SEEK,0,0,DATA_CORRECTED,BAD_TRACK
TYPE1_LEN	EQU	$-TYPE1_TABLE

TYPE2_TABLE	LABEL	BYTE
	DB	BAD_CMD,BAD_ADDR_MARK
TYPE2_LEN	EQU	$-TYPE2_TABLE

TYPE3_TABLE	LABEL	BYTE
	DB	BAD_CNTLR,BAD_CNTLR,BAD_ECC
TYPE3_LEN	EQU	$-TYPE3_TABLE

;-----  TYPE 0 ERROR

TYPE_0:
	MOV	BX,OFFSET TYPE0_TABLE
	CMP	AL,TYPE0_LEN		; CHECK IF ERROR IS DEFINED
	JAE	UNDEF_ERR_L
	XLAT	CS:TYPE0_TABLE		; TABLE LOOKUP
	MOV	DISK_STATUS,AL		; SET ERROR CODE
	RET

;------ TYPE 1 ERROR

TYPE_1:
	MOV	BX,OFFSET TYPE1_TABLE
	MOV	CX,AX
	CMP	AL,TYPE1_LEN		; CHECK IF ERROR IS DEFINED
	JAE	UNDEF_ERR_L
	XLAT	CS:TYPE1_TABLE		; TABLE LOOKUP
	MOV	DISK_STATUS,AL		; SET ERROR CODE
	AND	CL,08H			; CORRECTED ECC
	CMP	CL,08H
	JNZ	G30

;-----  OBTAIN ECC ERROR BURST LENGTH

	MOV	CMD_BLOCK+0,RD_ECC_CMD
	SUB	AL,AL
	CALL	COMMAND			; ISSUE THE COMMAND
	JC	G30
	MOV	AH,00001011B		; SET MASK FOR DATA INPUT CARD TO CPU
	CALL	HD_WAIT			; GO WAIT FOR THE INPUT STATE
	JC	G30
	DEC	DX			; ADDRESS PORT 0
	IN	AL,DX			; READ THE LENGTH OF THE ERROR
	MOV	CL,AL			;  CORRECTED AND SAVE IN CL
	MOV	AH,00001111B		; SET MASK FOR STATUS STATE
	CALL	HD_WAIT			; GO WAIT FOR STATUS STATE
	JC	G30
	DEC	DX			; ADDRESS PORT 0
	IN	AL,DX			; READ THE STATUS BYTE
	TEST	AL,2			; ERROR BIT SET?
	JZ	G30
	MOV	DISK_STATUS,BAD_CNTLR
	STC
G30:
	MOV	AL,CL
	RET

;----- TYPE 2 ERROR

TYPE_2:
	MOV	BX,OFFSET TYPE2_TABLE
	CMP	AL,TYPE2_LEN		; CHECK IF ERROR IS DEFINED
	JAE	UNDEF_ERR_L
	XLAT	CS:TYPE2_TABLE		; TABLE LOOKUP
	MOV	DISK_STATUS,AL		; SET ERROR CODE
	RET

;----- TYPE 3 ERROR

TYPE_3:
	MOV	BX,OFFSET TYPE3_TABLE
	CMP	AL,TYPE3_LEN		; CHECK IF ERROR IS DEFINED
	JAE	UNDEF_ERR_L
	XLAT	CS:TYPE3_TABLE		; TABLE LOOKUP
	MOV	DISK_STATUS,AL		; SET ERROR CODE
	RET

UNDEF_ERR_L:
	MOV	DISK_STATUS,UNDEF_ERR
	RET

;--------------------------------------------------------
; ON ENTRY AH CONTAINS THE CONTROLLER BUS STATUS DECODE :
; MASK USED TO CHECK THE HARDWARE STATUS.               :
;--------------------------------------------------------
HD_WAIT		PROC	NEAR
	PUSH	CX			; SAVE CX
	SUB	CX,CX			; SET THE LOOP COUNT
L1:
	CALL	PORT_0
	INC	DX			; PORT_1 ADDRESS
	IN	AL,DX			; READ THE HARDWARE STATUS
	AND	AL,00001111B		; CLEAR UPPER NIBBLE OF HARDWARE STATUS
	CMP	AL,AH			; CHECK THE STATE WITH THE MASK
	JZ	L2			; JMP IF O.K WITH CARRY CLEARED
	LOOP	L1			; TRY AGAIN
	MOV	DISK_STATUS,TIME_OUT
	STC				; SET ERROR CONDITION
L2:
	POP	CX			; RESTORE CX
	RET
HD_WAIT		ENDP

;--------------------------------------------------------
; DMA_SETUP                                             :
;       THIS ROUTINE SETS UP FOR DMA OPERATIONS.        :
; INPUT                                                 :
;       (AL) = MODE BYTE FOR THE DMA                    :
;       (ES:BX) = ADDRESS TO READ/WRITE THE DATA        :
; OUTPUT                                                :
;       (AX) DESTROYED                                  :
;--------------------------------------------------------
DMA_SETUP	PROC	NEAR
	CMP	CMD_BLOCK+4,81H		; BLOCK COUNT OUT OF RANGE
	JB	J1

	STC				; SET THE ERROR CONDITION
	RET

J1:
	CLI				; NO MORE INTERRUPTS
	OUT	DMA+12,AL		; SET THE FIRST/LAST F/F
	MOV	CL,4			; SHIFT COUNT
	OUT	DMA+11,AL		; OUTPUT THE MODE BYTE
	MOV	AX,ES			; GET THE ES VALUE
	ROL	AX,CL			; ROTATE LEFT
	MOV	CH,AL			; GET THE HIGHEST NIBBLE OF ES TO CH
	AND	AL,0F0H			; ZERO THE LOW NIBBLE FROM SEGMENT
	ADD	AX,BX			; TEST FOR CARRY FROM ADDITION
	ADC	CH,0			; CARRY MEANS HIGH 4 BITS MUST BE INC

	MOV	SI,AX			; SAVE START ADDRESS
	OUT	DMA+6,AL		; OUTPUT LOW ADDRESS
	MOV	AL,AH
	OUT	DMA+6,AL		; OUTPUT HIGH ADDRESS
	MOV	AL,CH			; GET HIGH 4 BITS
	AND	AL,0FH
	OUT	DMA_HIGH,AL		; OUTPUT THE HIGH 4 BITS TO PAGE REG

;------ DETERMINE COUNT

	MOV	AH,CMD_BLOCK+4		; RECOVER BLOCK COUNT
	SHL	AH,1			; MULTIPLY BY 512 BYTES PER SECTOR
	XOR	AL,AL			; CLEAR LOW BYTE
	DEC	AX			;   AND DECREMENT VALUE BY ONE

;----- HANDLE READ AND WRITE LONG (516D BYTES BLOCKS)

	CMP	CMD_BLOCK+0,RD_LONG_CMD
	JE	ADD4
	
	CMP	CMD_BLOCK+0,WR_LONG_CMD
	JNE	J20
ADD4:
	MOV	AX,516D			; ONE BLOCK (512) PLUS 4 BYTES ECC
	PUSH	BX
	SUB	BH,BH
	MOV	BL,CMD_BLOCK+4
	PUSH	DX
	MUL	BX			; BLOCK COUNT TIMES 516
	POP	DX
	POP	BX
	DEC	AX			; ADJUST
J20:
	MOV	CX,AX			; SAVE COUNT VALUE
	OUT	DMA+7,AL		; LOW BYTE OF COUNT
	MOV	AL,AH
	OUT	DMA+7,AL		; HIGH BYTE OF COUNT
	STI				; INTERRUPTS BACK ON
	MOV	AX,SI			; RECOVER ADDRESS VALUE
	ADD	AX,CX			; ADD, TEST FOR 64K OVERFLOW
	RET				; RETURN TO CALLER,
					;   CY SET BY ABOVE IF ERROR
DMA_SETUP	ENDP

;------------------------------------------------
; WAIT_INT                                      :
;       THIS ROUTINE WAITS FOR THE FIXED DISK   :
;       CONTROLLER TO SIGNAL THAT AN INTERRUPT  :
;       HAS OCCURRED.                           :
;------------------------------------------------
WAIT_INT	PROC	NEAR
	ASSUME	DS:ABS0
	STI				; TURN ON INTERRUPTS
	MOV	BX,DS			; SAVE DS
	SUB	AX,AX
	MOV	DS,AX			; ESTABLISH SEGMENT
	LES	SI,HF_TBL_VEC
	
	ASSUME	DS:DATA,ES:NOTHING
	MOV	DS,BX			; RESTORE DS

;----- SET TIMEOUT VALUES

	SUB	BH,BH
	MOV	BL,BYTE PTR ES:[SI][9]		; LOAD THE STANDARD TIME OUT
	MOV	AH,CMD_BLOCK+0
	CMP	AH,FMTDRV_CMD
	JNZ	W5

	MOV	BL,BYTE PTR ES:[SI][0AH]	; LOAD THE FORMAT DRIVE
	JMP	SHORT	W4			;  TIME OUT VALUE
W5:	CMP	AH,CHK_DRV_CMD
	JNZ	W4

	MOV	BL,BYTE PTR ES:[SI][0BH]	; LOAD THE CHECK DRIVE
W4:						;  TIME OUT VALUE
	CLC				; CLEAR CY
	MOV	AX,9000H		; DEVICE WAIT INTERRUPT
	INT	15H
	STI				; ENABLE INTERRUPTS FOR PC AND
					;  XT MACHINES
	SUB	CX,CX			; SET THE LOOP COUNT

;----- WAIT FOR INTERRUPT

W1:
	CALL	PORT_0
	DEC	DX			; PORT_1 ADDRESS
	IN	AL,DX			; READ THE HARDWARE STATUS
	TEST	AL,020H			; DID INTERRUPT OCCUR
	JZ	W2			; JUMP IF YES

	LOOP	W1			; INNER LOOP
	DEC	BX
	JNZ	W1			; OUTER LOOP

	MOV	DISK_STATUS,TIME_OUT
W2:
	DEC	DX			; ADDRESS PORT 0
	IN	AL,DX			; READ THE STATUS BYTE
	AND	AL,2			; ISOLATE THE ERROR BIT
	OR	DISK_STATUS,AL		; SAVE IN THE STATUS
	ADD	DX,3			; PORT_3 ADDRESS
	XOR	AL,AL			; ZERO
	OUT	DX,AL			; RESET INTERRUPT MASK
	RET

WAIT_INT	ENDP

;---  HD_INT  -------------------------------------------
;                                                       :
;       FIXED DISK INTERRUPT 0DH ROUTINE IRQ-5          :
;                                                       :
;--------------------------------------------------------

HD_INT	PROC	NEAR
	PUSH	AX			; SAVE WORK REGISTER
	MOV	AL,07H			; SET DMA MODE TO DISABLE
	OUT	DMA+10,AL
	CLI				; NO INTERRUPTS
	IN	AL,INTA01		; LOAD THE INTERRUPT ENABLE MASK
	OR	AL,020H			; TURN OFF FIXED DISK INTERRUPT IRQ-5
	OUT	INTA01,AL		; REPLACE THE MASK
	MOV	AL,EOI			; LOAD THE END OF INTERRUPT MASK
	OUT	INTA00,AL		; CLEAR THE ACTIVE INTERRUPT LEVEL
	STI				; INTERRUPTS BACK ON
	MOV	AX,9100H		; DEVICE POST
	INT	15H			;  INTERRUPT
	POP	AX			; RESTORE AX
	IRET
HD_INT	ENDP

;----------------------------------------
; PORTS                                 :
;       GENERATE PROPER PORT VALUE      :
;       BASED ON THE PORT OFFSET        :
;----------------------------------------

PORT_0	PROC	NEAR
	MOV	DX,HF_PORT		; BASE VALUE
	ADD	DL,PORT_OFF		; ADD IN OFFSET VALUE (00,04,08,0C)
	RET
PORT_0	ENDP

END_ADDRESS	LABEL	BYTE
CODE	ENDS
	END
